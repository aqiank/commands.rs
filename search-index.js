var searchIndex = {};
searchIndex["commands"] = {"doc":"# Commands","items":[[0,"parser","commands","# Command Parser",null,null],[3,"Parser","commands::parser","Command parser",null,null],[12,"nodes","","The nodes which have been accepted during `parse` or `advance`.",0,null],[12,"tokens","","The tokens which have been accepted during `parse` or `advance`.",0,null],[0,"tokenizer","","# Command Tokenization",null,null],[3,"SourceOffset","commands::parser::tokenizer","A position within a string.",null,null],[12,"char","","The index of this character within the string.",1,null],[12,"line","","The line number on which this character may be found.",1,null],[12,"column","","The column on which this character may be found.",1,null],[3,"SourceLocation","","A range within a string.",null,null],[12,"start","","The start of the range.",2,null],[12,"end","","The end of the range.",2,null],[3,"Token","","A token from a body of text.",null,null],[12,"text","","The text of the token.",3,null],[12,"token_type","","The type of the token (`Whitespace` or `Word`).",3,null],[12,"location","","The location of the token in the source body of text.",3,null],[4,"TokenType","","The role that a token plays: `Whitespace` or `Word`.",null,null],[13,"Invalid","","Internal usage only.",4,null],[13,"Whitespace","","The token represents whitespace and not a word.",4,null],[13,"Word","","The token represents a word within the string. This\ntakes double quoted strings into account.",4,null],[5,"tokenize","","Tokenize a body of text.",null,{"inputs":[{"name":"str"}],"output":{"name":"vec"}}],[11,"eq","","",1,{"inputs":[{"name":"sourceoffset"},{"name":"sourceoffset"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"sourceoffset"},{"name":"sourceoffset"}],"output":{"name":"bool"}}],[11,"fmt","","",1,{"inputs":[{"name":"sourceoffset"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Construct a `SourceOffset`.",1,{"inputs":[{"name":"usize"},{"name":"usize"},{"name":"usize"}],"output":{"name":"sourceoffset"}}],[11,"eq","","",2,{"inputs":[{"name":"sourcelocation"},{"name":"sourcelocation"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"sourcelocation"},{"name":"sourcelocation"}],"output":{"name":"bool"}}],[11,"fmt","","",2,{"inputs":[{"name":"sourcelocation"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Construct a `SourceLocation`.",2,{"inputs":[{"name":"sourceoffset"},{"name":"sourceoffset"}],"output":{"name":"sourcelocation"}}],[11,"eq","","",4,{"inputs":[{"name":"tokentype"},{"name":"tokentype"}],"output":{"name":"bool"}}],[11,"ne","","",4,{"inputs":[{"name":"tokentype"},{"name":"tokentype"}],"output":{"name":"bool"}}],[11,"fmt","","",4,{"inputs":[{"name":"tokentype"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",4,{"inputs":[{"name":"tokentype"}],"output":{"name":"tokentype"}}],[11,"eq","","",3,{"inputs":[{"name":"token"},{"name":"token"}],"output":{"name":"bool"}}],[11,"ne","","",3,{"inputs":[{"name":"token"},{"name":"token"}],"output":{"name":"bool"}}],[11,"fmt","","",3,{"inputs":[{"name":"token"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"new","","Construct a `Token`. The lifetime parameter `&#39;t` refers to the lifetime of the\ntext being tokenized.",3,{"inputs":[{"name":"str"},{"name":"tokentype"},{"name":"sourcelocation"}],"output":{"name":"token"}}],[0,"nodes","commands::parser","# Parser Nodes",null,null],[3,"RootNode","commands::parser::nodes","",null,null],[3,"CommandNode","","",null,null],[3,"WrapperNode","","",null,null],[3,"ParameterNameNode","","",null,null],[3,"FlagParameterNode","","",null,null],[3,"NamedParameterNode","","",null,null],[3,"SimpleParameterNode","","",null,null],[3,"NodeFields","","A parse tree node.",null,null],[12,"successors","","Possible successor nodes. Collected while building.",5,null],[12,"name","","The name of this node.",5,null],[12,"priority","","Match and complete priority.",5,null],[12,"hidden","","Hidden nodes are not completed. This doesn&#39;t modify matching.",5,null],[3,"CommandNodeFields","","",null,null],[3,"WrapperNodeFields","","",null,null],[3,"RepeatableNodeFields","","",null,null],[3,"ParameterNameNodeFields","","",null,null],[3,"ParameterNodeFields","","",null,null],[17,"PRIORITY_MINIMUM","","Minimum priority.",null,null],[17,"PRIORITY_PARAMETER","","The default priority for a parameter.",null,null],[17,"PRIORITY_DEFAULT","","The default priority.",null,null],[8,"Node","","",null,null],[11,"as_command_node","","",6,{"inputs":[{"name":"node"}],"output":{"name":"option"}}],[8,"ParameterNode","","",null,null],[0,"completion","commands::parser","# Completion",null,null],[3,"CompletionOption","commands::parser::completion","Represents a single option returned by `complete`.",null,null],[12,"option_string","","String for this option.",7,null],[12,"complete","","True if this option is complete and a valid value.",7,null],[3,"Completion","","Represents the result of completing a node.",null,null],[12,"help_symbol","","Value placeholder for help.",8,null],[12,"help_text","","Main help text.",8,null],[12,"token","","Token used to hint the completion, if provided.",8,null],[12,"exhaustive","","Was this completion exhaustive? If yes, then only\nthe given completion options are valid.",8,null],[12,"options","","The actual completion options.",8,null],[8,"Complete","","Trait for nodes that support completion.",null,null],[10,"complete","","Given a node and an optional token, provide the completion options.",9,{"inputs":[{"name":"complete"},{"name":"option"}],"output":{"name":"completion"}}],[11,"new","","CompletionOption constructor",7,{"inputs":[{"name":"str"},{"name":"bool"}],"output":{"name":"completionoption"}}],[11,"new","","",8,{"inputs":[{"name":"node"},{"name":"option"},{"name":"bool"},{"name":"vec"},{"name":"vec"}],"output":{"name":"completion"}}],[11,"complete","commands::parser","",6,{"inputs":[{"name":"node"},{"name":"option"}],"output":{"name":"completion"}}],[11,"complete","commands::parser::nodes","",10,{"inputs":[{"name":"rootnode"},{"name":"option"}],"output":{"name":"completion"}}],[11,"new","commands::parser","Construct a parser with a root node.",0,{"inputs":[{"name":"rootnode"}],"output":{"name":"parser"}}],[11,"push_command","","XXX: Temporarily public.",0,{"inputs":[{"name":"parser"},{"name":"node"}],"output":null}],[11,"parse","","Parse a vector of tokens, advancing through the\nnode hierarchy.",0,{"inputs":[{"name":"parser"},{"name":"vec"}],"output":null}],[11,"advance","","Parse a single token, advancing through the node hierarchy.",0,{"inputs":[{"name":"parser"},{"name":"token"}],"output":null}]],"paths":[[3,"Parser"],[3,"SourceOffset"],[3,"SourceLocation"],[3,"Token"],[4,"TokenType"],[3,"NodeFields"],[8,"Node"],[3,"CompletionOption"],[3,"Completion"],[8,"Complete"],[3,"RootNode"]]};
initSearch(searchIndex);
